<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sync PS4 Cheats to Supabase</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 800px;
    margin: 50px auto;
    padding: 20px;
    background: #1a1a1a;
    color: #fff;
  }
  h1 { color: #00d4ff; }
  button {
    padding: 12px 24px;
    margin: 10px;
    font-size: 16px;
    background: #00d4ff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    color: #000;
    font-weight: bold;
  }
  button:hover { background: #00b8e6; }
  button:disabled { background: #666; cursor: not-allowed; }
  #status {
    margin-top: 20px;
    padding: 15px;
    background: #2a2a2a;
    border-radius: 6px;
    min-height: 100px;
    font-family: monospace;
  }
  .success { color: #4caf50; }
  .error { color: #f44336; }
  .warning { color: #ff9800; }
  .config {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 6px;
    margin-bottom: 20px;
  }
  .config input {
    width: 100%;
    padding: 8px;
    margin: 5px 0;
    background: #1a1a1a;
    border: 1px solid #444;
    color: #fff;
    border-radius: 4px;
  }
  .config label {
    display: block;
    margin-top: 10px;
    color: #aaa;
  }
</style>
</head>
<body>

<h1>üéÆ Sync PS4 Cheats to Supabase</h1>

<div class="config">
  <h3>Supabase Configuration</h3>
  <label>Supabase URL:</label>
  <input type="text" id="supabaseUrl" placeholder="https://xxxxx.supabase.co">
  
  <label>Supabase Anon Key:</label>
  <input type="text" id="supabaseKey" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...">
  
  <button onclick="saveConfig()">üíæ Save Config</button>
</div>

<div>
  <button onclick="syncAll()">üì• Initial Sync (All Games)</button>
  <button onclick="syncNew()">üîÑ Sync New Games Only</button>
  <button onclick="checkStats()">üìä Check Database Stats</button>
</div>

<div id="status"></div>

<script>
const CDN = 'https://cdn.jsdelivr.net/gh/GoldHEN/GoldHEN_Cheat_Repository@main';
let supabase = null;

// üîß HARDCODED CREDENTIALS (Optional - will override localStorage)
const HARDCODED_URL = 'https://bnljbsdbosnxsgvriosr.supabase.co';
const HARDCODED_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJubGpic2Rib3NueHNndnJpb3NyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE2NDA4NDQsImV4cCI6MjA4NzIxNjg0NH0.KBiswV89XDnjtWMOFk4VGhjcwapHEsLhdpX_2K60p7c';

// Load saved config
window.addEventListener('DOMContentLoaded', () => {
  // Use hardcoded values first, fallback to localStorage
  const url = HARDCODED_URL || localStorage.getItem('supabaseUrl');
  const key = HARDCODED_KEY || localStorage.getItem('supabaseKey');
  
  if (url) document.getElementById('supabaseUrl').value = url;
  if (key) document.getElementById('supabaseKey').value = key;
  
  if (url && key) {
    supabase = window.supabase.createClient(url, key);
    const source = HARDCODED_URL ? 'hardcoded values' : 'localStorage';
    log(`‚úÖ Config loaded from ${source}`, 'success');
  }
});

function saveConfig() {
  const url = document.getElementById('supabaseUrl').value;
  const key = document.getElementById('supabaseKey').value;
  
  if (!url || !key) {
    log('Please enter both URL and Key', 'error');
    return;
  }
  
  localStorage.setItem('supabaseUrl', url);
  localStorage.setItem('supabaseKey', key);
  supabase = window.supabase.createClient(url, key);
  log('‚úÖ Configuration saved!', 'success');
}

function log(message, type = '') {
  const status = document.getElementById('status');
  const time = new Date().toLocaleTimeString();
  status.innerHTML += `<div class="${type}">[${time}] ${message}</div>`;
  status.scrollTop = status.scrollHeight;
}

async function checkStats() {
  if (!supabase) {
    log('Please configure Supabase first!', 'error');
    return;
  }
  
  log('Checking database stats...', '');
  
  const { data: games, error: gamesError } = await supabase.from('games').select('id', { count: 'exact', head: true });
  const { data: cheats, error: cheatsError } = await supabase.from('cheats').select('id', { count: 'exact', head: true });
  
  if (gamesError || cheatsError) {
    log('Error checking stats. Make sure tables exist!', 'error');
    log('Run this SQL in Supabase SQL Editor:', 'warning');
    log(`
CREATE TABLE IF NOT EXISTS games (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  version TEXT,
  process TEXT,
  credits TEXT[],
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS cheats (
  id BIGSERIAL PRIMARY KEY,
  game_id TEXT REFERENCES games(id),
  name TEXT NOT NULL,
  type TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS sync_log (
  id BIGSERIAL PRIMARY KEY,
  last_synced_at TIMESTAMP DEFAULT NOW(),
  files_synced INTEGER,
  new_games INTEGER
);
    `, '');
    return;
  }
  
  log(`üìä Database Stats:`, 'success');
  log(`   Games: ${games?.length || 0}`, '');
  log(`   Cheats: ${cheats?.length || 0}`, '');
}

async function syncAll() {
  if (!supabase) {
    log('Please configure Supabase first!', 'error');
    return;
  }
  
  log('Starting full sync...', 'warning');
  log('Fetching file list from GitHub...', '');
  
  try {
    const listRes = await fetch(`${CDN}/json.txt`);
    const listText = await listRes.text();
    const files = listText.trim().split('\n').map(l => {
      const eqIndex = l.trim().indexOf('=');
      return eqIndex > 0 ? l.trim().substring(0, eqIndex) : l.trim();
    }).filter(l => l.endsWith('.json'));
    
    log(`Found ${files.length} files`, 'success');
    
    let synced = 0;
    let errors = 0;
    const BATCH = 20;
    
    for (let i = 0; i < files.length; i += BATCH) {
      const batch = files.slice(i, i + BATCH);
      
      await Promise.all(batch.map(async fname => {
        try {
          const r = await fetch(`${CDN}/json/${fname}`);
          const data = await r.json();
          
          if (!data.id || !data.name) return;
          
          // Insert game
          const { error: gameError } = await supabase.from('games').upsert({
            id: data.id,
            name: data.name,
            version: data.version || null,
            process: data.process || null,
            credits: data.credits || null
          }, { onConflict: 'id' });
          
          if (gameError) throw gameError;
          
          // Delete old cheats for this game
          await supabase.from('cheats').delete().eq('game_id', data.id);
          
          // Insert new cheats
          if (data.mods && data.mods.length > 0) {
            const cheats = data.mods.map(mod => ({
              game_id: data.id,
              name: mod.name || 'Unknown',
              type: mod.type || null
            }));
            
            const { error: cheatsError } = await supabase.from('cheats').insert(cheats);
            if (cheatsError) throw cheatsError;
          }
          
          synced++;
        } catch(e) {
          console.error('Error syncing:', fname, e);
          errors++;
        }
      }));
      
      log(`Progress: ${synced}/${files.length} games synced (${errors} errors)`, '');
    }
    
    // Log sync
    await supabase.from('sync_log').insert({
      files_synced: files.length,
      new_games: synced
    });
    
    log(`‚úÖ SYNC COMPLETE!`, 'success');
    log(`   Synced: ${synced} games`, 'success');
    log(`   Errors: ${errors}`, errors > 0 ? 'error' : '');
    
  } catch(err) {
    log(`‚ùå Sync failed: ${err.message}`, 'error');
  }
}

async function syncNew() {
  if (!supabase) {
    log('Please configure Supabase first!', 'error');
    return;
  }
  
  log('Checking for new games...', 'warning');
  
  try {
    // Get existing game IDs
    const { data: existing } = await supabase.from('games').select('id');
    const existingIds = new Set(existing.map(g => g.id));
    log(`Found ${existingIds.size} existing games in database`, '');
    
    const listRes = await fetch(`${CDN}/json.txt`);
    const listText = await listRes.text();
    const files = listText.trim().split('\n').map(l => {
      const eqIndex = l.trim().indexOf('=');
      return eqIndex > 0 ? l.trim().substring(0, eqIndex) : l.trim();
    }).filter(l => l.endsWith('.json'));
    
    log(`Found ${files.length} files on GitHub`, '');
    
    let newGames = 0;
    let errors = 0;
    
    for (const fname of files) {
      try {
        const r = await fetch(`${CDN}/json/${fname}`);
        const data = await r.json();
        
        if (!data.id || !data.name) continue;
        
        if (!existingIds.has(data.id)) {
          // Insert new game
          const { error: gameError } = await supabase.from('games').insert({
            id: data.id,
            name: data.name,
            version: data.version || null,
            process: data.process || null,
            credits: data.credits || null
          });
          
          if (gameError) throw gameError;
          
          // Insert cheats
          if (data.mods && data.mods.length > 0) {
            const cheats = data.mods.map(mod => ({
              game_id: data.id,
              name: mod.name || 'Unknown',
              type: mod.type || null
            }));
            
            const { error: cheatsError } = await supabase.from('cheats').insert(cheats);
            if (cheatsError) throw cheatsError;
          }
          
          newGames++;
          log(`Added: ${data.name} [${data.id}]`, 'success');
        }
      } catch(e) {
        console.error('Error:', fname, e);
        errors++;
      }
    }
    
    // Log sync
    await supabase.from('sync_log').insert({
      files_synced: files.length,
      new_games: newGames
    });
    
    if (newGames > 0) {
      log(`‚úÖ Added ${newGames} new games!`, 'success');
    } else {
      log(`‚úÖ No new games found. Database is up to date!`, 'success');
    }
    
    if (errors > 0) {
      log(`‚ö†Ô∏è ${errors} errors occurred`, 'warning');
    }
    
  } catch(err) {
    log(`‚ùå Sync failed: ${err.message}`, 'error');
  }
}
</script>

</body>
</html>
